# 引导诊断

此部分提供与客户端系统诊断相关的具体例子供参考。

## 还原卡相关

学校机房的计算机通常有还原卡（或者同等功能的软件），用以保护系统不被损坏。但此类软硬件可能对 thupxe 的部署造成一定的困难，包括且不限于：

* 无法更改引导配置，或者引导配置被劫持；
* 无法在硬盘上创建分区，或者无法在分区中持久化地写入数据；
* 引导过程中增加额外的限制（如警告弹窗、密码输入）。

此处提供部分含有还原卡的计算机配置方法。绝大部分还原卡的工作原理是在硬盘的某处（通常是一个专用分区），存储每个操作系统所使用的分区和这些分区的信息。
在引导某一系统时，根据上述信息重写分区表，只创建该系统所使用的分区，即可引导该系统。数据保护则通过系统中的 IO 驱动拦截实际读写来实现。

### 计算机一

Dell，有还原卡。可通过同传系统复制 iPXE 和分区结构，thupxe 持久化数据位于未分区的空隙中。

1. 进入安装有还原卡驱动的 Windows 系统，右键单击托盘中的“磁盘监视器”——登录，进入还原卡管理工具的分区工具。
2. 如有必要，删除一些已有的系统以获得可用空间。创建新的分区和系统，名称为 iPXE，分区表格式为 GPT，文件系统必须为 FAT32，大小尽量小（以节省传送时间），但需要大于 300MB（否则无法识别为系统分区）。由于还原卡只支持从后往前删除系统，所以建议使用最后一个分区。
3. 点击“更新分区”后，还原系统会自动创建 ESP 分区、MSR 分区和对应的系统分区（部署中不使用后两者），并重启。
4. 重启后，按 F12 选择 LiveUSB 引导。依旧会进入还原卡界面，按 Home 进入管理。将鼠标移动到 iPXE，按 Ctrl-O 进入临时开放模式，再次选择 U 盘引导，进入 Ubuntu Live。
5. 在磁盘管理工具中确认 ESP 分区的编号和设备名称，格式化为 FAT32。挂载 ESP 分区，将 `ipxe.efi` 放置到 `EFI/BOOT/bootx64.efi`。卸载 ESP 分区。
6. 进入 iPXE，应当可以正常进入 PXE 流程，从服务器部署系统。
7. 重启到 Windows。进入还原卡“系统设置”，将默认系统修改为 iPXE。此外，可以将其他系统在启动菜单中隐藏（名称前加`~`）。进入分区工具，将所有共享分区对 iPXE 系统隐藏（取消分区），点击“更新分区”重启。
8. 确认无误后，使用同传功能将 CMOS 参数、分区表相关参数、iPXE 分区数据（只要选 ESP）、配置（默认系统）传送到各个机器。重启，验证各机器正确工作。

### 计算机二

HP，有还原卡。可通过同传系统复制 iPXE 和分区结构，thupxe 持久化数据位于未分区的空隙中。

1. 进入安装有还原卡驱动的 Windows 系统 / 开机按 F10，右键单击托盘中的“噢易”——登录，进入还原卡管理工具。
2. 如有必要，删除一个已有的系统以获得可用空间。创建新的系统分区，名称为 iPXE，分区表格式为 GPT，大小尽量小。
3. 点击“执行”后，还原卡会自动创建 ESP 分区和对应的系统分区（部署中不使用后者）。
4. 重启到还原卡界面，按 F10 进入管理，选择安装系统，选择 iPXE 分区，并选择准备好的 LiveUSB 引导，进入 Ubuntu Live。
5. 在磁盘管理工具中确认 ESP 分区的编号和设备名称，格式化为 FAT32。挂载 ESP 分区，将 `ipxe.efi` 放置到 `EFI/BOOT/bootx64.efi`。卸载 ESP 分区。
6. 重启到还原卡界面，此时可以调整默认系统为 iPXE，隐藏其他系统。引导 iPXE 系统，应当可以正常进入 PXE 流程，从服务器部署系统。
7. 确认无误后，使用同传系统中的“差异拷贝”功能将分区表相关参数、iPXE 分区数据（需要选择“逐个扇区发送”）、配置（默认系统选择等）传送到各个机器。重启，验证各机器正确工作。注意：同传系统依赖于 WoL 和 PXE 启动，在进行同传时，需要关闭服务器的 DHCP，以免造成混乱。

### 计算机三

Dell，有还原卡。可通过同传系统复制 iPXE 和分区结构，thupxe 持久化数据位于未分区的空隙中。

1. 在 Windows 系统中打开还原卡的分区管理
2. 选择分区 2（数据分区），删除分区
3. 选择添加系统，名称 iPXE，系统类型 Linux，系统盘容量 5GB（只使用 EFI 分区，其他无用分区空间太大，会浪费传输时间）
4. 选择 Windows 10 系统，选择系统属性，添加 `~` 隐藏
5. 点击分区更新，确认，等待系统重启
6. 重新进入 Windows 10，进入还原卡系统设置，更改默认系统为 iPXE
7. 插入 U 盘，在引导界面移动到 iPXE 按 Ctrl-O 进入 U 盘引导
   1. 格式化 EFI 分区，将提供的 `ipxe.efi` 放置到 EFI 分区的 `/EFI/BOOT/bootx64.efi`
   2. 分区表结构会在下次引导之后被覆盖，因此只能使用现有的分区结构（或者后部未使用空间）
8. 重启进入 iPXE 系统，检查是否正常引导至 Linux

### 计算机四

Lenovo，有固件中嵌入的教育版同传/还原软件。

<!-- 其选择启动操作系统的原理是，在硬盘的一个分区中，存储每个操作系统所使用的分区和这些分区的信息。
在引导某一系统时，根据上述信息重写分区表，只创建该系统所使用的分区，即可引导该系统。 -->
该软件同时支持创建数据分区。可以将系统镜像等文件放置在数据分区中，使用 thupxe
完成系统镜像的传输。但是，需要借用同传系统复制 iPXE 引导文件。具体操作步骤如下：

1. 利用该软件创建一个 FAT32 类型的 GPT 系统分区，大小为 300M（是最允许的分区大小）；

    此时，该软件会自动创建一个 ESP 分区，大小为 100M，用于存放引导文件

2. 将上述信件的系统分区作为默认系统，并隐藏原有的系统分区；
3. 使用新建的系统分区引导系统；

    此时并不能成功引导，但还原软件会创建好分区表
4. 选择引导介质为含有 Linux Live 系统的 U 盘，进入 Linux 系统；

    对于该还原软件而言，相当于是在“安装”操作系统

5. 在 Linux 系统中，会发现硬盘有三个分区，依次是还原软件元信息分区、ESP 分区（100M）和系统分区（300M）；
6. 使用 FAT32 格式化（`mkfs.msdos -F 32`） ESP 分区和系统分区，并在 ESP 分区中写入 iPXE 引导文件，系统分区不写入任何文件；
7. 挂载还原软件元信息分区，解密其存储的信息文件，在解密后的文件中，将系统分区对应是否安装驱动的标志由 `00` 改为 `01`，并修正校验和；
8. 将信息文件加密后写回，并重启；
9. 此时即可正常进入 iPXE，同时因为驱动安装标志有效，可以利用同传功能将 iPXE 引导文件复制到其他机器上。

## 系统问题

此部分列举一些遇到的典型问题，以及解决方法。

### 计算机五

HP 一体机。

该系统在引导 Linux 后，当加载到 i915 驱动时，会出现黑屏，但系统仍在运行。此时可以通过以下方法解决：

* 修改 BIOS 选项，将安全启动选项由“Legacy 支持启用，安全启动禁用”调整为“Legacy 支持禁用，安全启动禁用”，即禁用其 Legacy 支持。

### U 盘六

U 盘，作为专用存储，型号为 CZ810

该型 U 盘在引导后，发现速率为 USB 2.0，致使使用体验较差。该问题为 U 盘本身的问题，
推测其原因是，在引导时，固件仅包括基本的 USB 2.0 驱动，使得设备使用 USB 2.0 模式与主机通信，
进入系统后，重新枚举 USB 设备时，U 盘并未退出 USB 2.0 模式，而是维持在该模式，导致速率极慢。

### 计算机七

此型号的机器在重启后 PXE 无法初始化硬件，导致引导失败。

可在 `pxe.conf` 中插入片段，强制启用网卡的 WOL 功能，（需要在 initramfs 中预置 ethtool）。

```bash
for i in /sys/class/net/en*; do
 if [ "$(cat "$i/type")" = "1" ]; then
   intf="$(basename "$i")"
   ethtool -s "$intf" wol g || true
 fi
done
```

### 计算机八

部分机器不方便修改引导项目或者因为某些原因无法持久化，但可以在开机时手工选择引导项。

可在 `pxe.conf` 中插入片段，自动向 UEFI 固件写入下次引导项为本次使用的引导项，以解决有时引导配置无法持久化的问题：

``` bash
(
  mkdir -p /run/efivarfs
  if mount -t efivarfs efivarfs /run/efivarfs; then
    if [ -e "/run/efivarfs/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c" ]; then
      bootcurrent=$(dd if=/run/efivarfs/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c bs=1 count=2 skip=4 | xxd -p)
      echo "BootCurrent: $bootcurrent"
      (echo -ne '\x07\x00\x00\x00'; dd if=/run/efivarfs/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c bs=1 count=2 skip=4) > /tmp/.bootnext
      cat /tmp/.bootnext >/run/efivarfs/BootNext-8be4df61-93ca-11d2-aa0d-00e098032b8c
      if [ "$?" -eq 0 ]; then
        echo "Write bootnext"
      else
        echo "Cannot Write bootnext"
      fi
    fi
    umount /run/efivarfs
  fi
  rmdir /run/efivarfs
)
```
